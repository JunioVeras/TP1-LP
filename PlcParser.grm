(* Convert a list into a string *)
fun myList2string (conv, l) =
    case l of
      [] => ""
    | h::[] => conv(h)
    | h::ts => conv(h) ^ ", " ^ list2string (conv, ts);

fun myType2string t =
    case t of
      BoolT => "BoolT"
    | IntT => "IntT"
    | ListT [] => "ListT []"
    | ListT ts => "ListT([" ^ myList2string (myType2string, ts) ^ "])"
    | SeqT t1 => "SeqT(" ^ type2string(t1) ^ ")"
    | FunT (t1, t2) => "FunT(" ^ myType2string(t1) ^ "->" ^ myType2string(t2) ^ ")";

fun exp2string (ConI(i)) = "ConI(" ^ Int.toString(i) ^ ")"
  | exp2string (ConB(b)) = "ConB(" ^ Bool.toString(b) ^ ")"
  | exp2string (ESeq(t)) = "ESeq(" ^ myType2string(t) ^ ")"
  | exp2string (Var(x)) = "Var(" ^ x ^ ")"
  | exp2string (Let(x, e1, e2)) = "Let()"
  | exp2string (Letrec(f, typeL, d, return, e1, e2)) = "Letrec()"
  | exp2string (Prim1(operation, x)) = "Prim1(\"" ^ operation ^ "\", " ^ exp2string(x) ^ ")"
  | exp2string (Prim2(operation, x, y)) = "Prim2(\"" ^ operation ^ "\", " ^ exp2string(x) ^ ", " ^ exp2string(y) ^ ")"
  | exp2string (If(x, y, z)) = "If(" ^ exp2string(x) ^ ", " ^ exp2string(y) ^ ", " ^ exp2string(z) ^ ")"
  | exp2string (Match(e, l)) = "Match()"
  | exp2string (Call(arg, e)) = "Call()"
  | exp2string (List(l)) = "List [" ^ myList2string (exp2string, l) ^ "]"
  | exp2string (Item(i, x)) = "Item(" ^ Int.toString(i) ^ ", " ^ exp2string(x) ^ ")"
  | exp2string (Anon(typeL, d, e)) = "Anon()";

fun getListOfTypes (ListT(l)) = l;

%%

%name PlcParser
%pos int

%right SEMI ARROW
%nonassoc IF
%left ELSE
%left AND
%left EQ DIF
%left LESS LESSEQ
%left INFIX
%left PLUS MINUS
%left TIMES DIV
%nonassoc NOT HD TL ISE PRINT
%left OBRACE

%term   NUM of int      |
        PLUS            |
        MINUS           |
        TIMES           |
        DIV             |
        EQ              |
        DIF             |
        LESS            |
        LESSEQ          |

        BOOL of bool    |
        AND             |
        NOT             |

        HD              |
        TL              |
        ISE             |
        INFIX           |

        PRINT           |

        OPAR            |
        CPAR            |
        OBRACE          |
        CBRACE          |
        OBRACKET        |
        CBRACKET        |
        SEMI            |
        COMMA           |
        ARROW           |

        IF              |
        THEN            |
        ELSE            |
        MATCH           |
        WITH            |


        NIL_T           |
        BOOL_T          |
        INT_T           |

        EOF

%nonterm    Prog of unit        |
            Expr of expr        |
            AtomExpr of expr    |
            Const of expr       |
            Type of plcType     |
            AtomType of plcType |
            Types of plcType


%eop EOF
%noshift EOF
%start Prog

%%

Prog    : Expr                  (print ("result = "^ exp2string(Expr) ^ "\n" ))

Expr    : AtomExpr              (AtomExpr)
        | IF Expr THEN Expr ELSE Expr (If(Expr1, Expr2, Expr3))
        | NOT Expr              (Prim1("!", Expr))
        | MINUS Expr            (Prim1("~", Expr))
        | HD Expr               (Prim1("hd", Expr))
        | TL Expr               (Prim1("tl", Expr))
        | ISE Expr              (Prim1("ise", Expr))
        | PRINT Expr            (Prim1("print", Expr))
        | Expr AND Expr         (Prim2("&&", Expr1, Expr2))
        | Expr PLUS Expr        (Prim2("+", Expr1, Expr2))
        | Expr MINUS Expr       (Prim2("-", Expr1, Expr2))
        | Expr TIMES Expr       (Prim2("*", Expr1, Expr2))
        | Expr DIV Expr         (Prim2("/", Expr1, Expr2))
        | Expr EQ Expr          (Prim2("=", Expr1, Expr2))
        | Expr DIF Expr         (Prim2("!=", Expr1, Expr2))
        | Expr LESS Expr        (Prim2("<", Expr1, Expr2))
        | Expr LESSEQ Expr      (Prim2("<=", Expr1, Expr2))
        | Expr INFIX Expr       (Prim2("::", Expr1, Expr2))
        | Expr SEMI Expr        (Prim2(";", Expr1, Expr2))
        | Expr OBRACE NUM CBRACE(Item(NUM, Expr))

AtomExpr: Const                 (Const)
        | OPAR Expr CPAR        (Expr)

Const   : BOOL                  (ConB(BOOL))
        | NUM                   (ConI(NUM))
        | OPAR CPAR             (List([]))
        | OPAR Type OBRACE CBRACE CPAR (ESeq(Type))

Type    : AtomType              (AtomType)
        | OPAR Types CPAR       (Types)
        | OBRACE Type CBRACE    (SeqT(Type))
        | Type ARROW Type       (FunT(Type1, Type2))

AtomType: NIL_T                 (ListT [])
        | BOOL_T                (BoolT)
        | INT_T                 (IntT)
        | OPAR Type CPAR        (Type)

Types   : Type COMMA Type       (ListT([Type1, Type2]))
        | Type COMMA Types      (ListT(Type::(getListOfTypes(Types))))

    (* let val s = "([(Nil, Int, Bool)] [])";
        val e = ESeq (SeqT (ListT [ListT [], IntT, BoolT])) *)